import type { Case, Entity, Theory, TimelineEvent, Relationship } from "../drizzle/schema";

export interface ReportData {
  case: Case;
  entities: Entity[];
  theories: Theory[];
  timelineEvents: TimelineEvent[];
  relationships: Relationship[];
}

export function generateMarkdownReport(data: ReportData): string {
  const { case: caseData, entities, theories, timelineEvents, relationships } = data;

  const report = `# Forensic OSINT Investigation Report: ${caseData.title}

**Date of Report:** ${new Date().toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" })}
**Case Subject:** ${caseData.subject}
**Date of Incident:** ${caseData.dateOfIncident ? new Date(caseData.dateOfIncident).toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" }) : "Unknown"}
**Location:** ${caseData.location || "Unknown"}
**Status:** ${caseData.status}

## Executive Summary

${caseData.description || "No description provided."}

## I. Case Timeline

${generateTimelineTable(timelineEvents)}

## II. Entity Map

${generateEntityTable(entities)}

## III. Relationships

${generateRelationshipsSection(relationships, entities)}

## IV. Theories and Probability Analysis

${generateTheoriesSection(theories)}

## V. Conclusion and Recommendations

${generateConclusion(theories)}

---

*This report was generated by the Forensic OSINT Report Generator on ${new Date().toISOString()}*
`;

  return report;
}

function generateTimelineTable(events: TimelineEvent[]): string {
  if (events.length === 0) {
    return "No timeline events recorded.";
  }

  let table = `| Time | Event | Significance |\n`;
  table += `| :--- | :--- | :--- |\n`;

  for (const event of events) {
    const time = new Date(event.eventTime).toLocaleString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
    table += `| **${time}** | ${event.eventDescription} | ${event.significance || "N/A"} |\n`;
  }

  return table;
}

function generateEntityTable(entities: Entity[]): string {
  if (entities.length === 0) {
    return "No entities recorded.";
  }

  let table = `| Entity Type | Name | Description |\n`;
  table += `| :--- | :--- | :--- |\n`;

  for (const entity of entities) {
    table += `| **${entity.entityType}** | **${entity.name}** | ${entity.description || "N/A"} |\n`;
  }

  return table;
}

function generateRelationshipsSection(relationships: Relationship[], entities: Entity[]): string {
  if (relationships.length === 0) {
    return "No relationships recorded.";
  }

  const entityMap = new Map(entities.map((e) => [e.id, e.name]));

  let section = "";
  for (const rel of relationships) {
    const fromName = entityMap.get(rel.fromEntityId) || "Unknown";
    const toName = entityMap.get(rel.toEntityId) || "Unknown";
    section += `- **${fromName}** → **${rel.relationshipType}** → **${toName}**`;
    if (rel.description) {
      section += `: ${rel.description}`;
    }
    section += `\n`;
  }

  return section;
}

function generateTheoriesSection(theories: Theory[]): string {
  if (theories.length === 0) {
    return "No theories recorded.";
  }

  let section = "";
  for (const theory of theories) {
    section += `### ${theory.title} (Probability: ${theory.probability}%, Status: ${theory.status})\n\n`;
    section += `${theory.description}\n\n`;
    if (theory.verificationFormula) {
      section += `**Verification Formula:** ${theory.verificationFormula}\n\n`;
    }
  }

  return section;
}

function generateConclusion(theories: Theory[]): string {
  const verifiedTheories = theories.filter((t) => t.status === "verified");
  const eliminatedTheories = theories.filter((t) => t.status === "eliminated");

  let conclusion = "";

  if (verifiedTheories.length > 0) {
    const highestProbability = verifiedTheories.reduce((max, t) => (t.probability > max.probability ? t : max));
    conclusion += `The investigation has verified the **${highestProbability.title}** theory as the most probable scenario (${highestProbability.probability}% probability).\n\n`;
  }

  if (eliminatedTheories.length > 0) {
    conclusion += `The following theories have been eliminated through the process of elimination:\n`;
    for (const theory of eliminatedTheories) {
      conclusion += `- ${theory.title}\n`;
    }
    conclusion += `\n`;
  }

  conclusion += `**Recommended Next Steps:**\n\n`;
  conclusion += `1. Conduct further investigation based on the verified theories.\n`;
  conclusion += `2. Gather additional evidence to support or refute pending theories.\n`;
  conclusion += `3. Consult with relevant authorities and experts for specialized analysis.\n`;

  return conclusion;
}

export function generateMaltegoGraphData(data: ReportData): string {
  const { entities, relationships } = data;

  const nodes = entities.map((e) => ({
    id: e.id,
    label: e.name,
    type: e.entityType,
    description: e.description,
  }));

  const edges = relationships.map((r) => ({
    from: r.fromEntityId,
    to: r.toEntityId,
    label: r.relationshipType,
    description: r.description,
  }));

  return JSON.stringify({ nodes, edges }, null, 2);
}

